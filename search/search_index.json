{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nrg-parser | Documentation","text":"<p>IEA task 43 parsers for NRG Systems, Inc. SymphoniePRO loggers.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install with pip</p> <p><code>pip install nrg-parser</code></p>"},{"location":"#usage","title":"Usage","text":"<p>This package takes the TXT exports of SymphoniePRO data files, and converts the metadata there into IEA Task 43 format.</p> <p>NOTE: For converting binary SymphoniePRO/Symphonie Classic data files into TXT, see the nrgpy repository.</p>"},{"location":"#example-notebook","title":"Example Notebook","text":""},{"location":"#iea-task43-metadata-parser","title":"IEA Task43 Metadata Parser","text":"<p>This notebook includes some examples for extracting IEA Task43 metadata from NRG Systems Symphonie-series data logger data files.</p> <p>See README.md, docs, and the Task43 Github page for more information:</p> <ul> <li>README.md</li> <li>docs</li> <li>Task43 Github</li> </ul> <pre><code>import nrg_parser\n</code></pre>"},{"location":"#instantiate-the-nrg_parser-object","title":"Instantiate the nrg_parser object","text":"<pre><code>metadata = nrg_parser.SymphonieProTxtReader(\n    txt_filepath=\"tests/files/004310_2022-03-17_00.00_000835_meas.txt\"\n)\n</code></pre>"},{"location":"#run-the-get_all_metadata-method-or-run-through-the-metadata-methods-individually","title":"Run the <code>get_all_metadata</code> method, or run through the metadata methods individually:","text":"<ul> <li><code>get_header</code></li> <li><code>get_site_info</code></li> <li><code>get_iea_logger_main_config</code></li> <li><code>get_iea_sensor_config</code></li> </ul> <pre><code>metadata.get_all_metadata()\n</code></pre>"},{"location":"#iea-metadata-objects-end-in-_dict","title":"IEA metadata objects end in <code>_dict</code>","text":"<ul> <li><code>header_sections_dict</code></li> <li><code>logger_main_config_dict</code></li> <li><code>sensor_config_dict_list</code></li> </ul> <pre><code>metadata.header_sections_dict\n</code></pre> <pre><code>metadata.logger_main_config_dict\n</code></pre> <pre><code>metadata.sensor_config_dict_list\n</code></pre>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#reference-built-from-docstrings","title":"Reference built from docstrings","text":"<p>This section of the documentation comes directly from the codebase. Use this for specific module/class/method usage information.</p> <p>nrg_parser</p> <p>common</p>"},{"location":"reference/common/","title":"Index","text":""},{"location":"reference/common/logger/","title":"Logger","text":""},{"location":"reference/common/utilities/","title":"Index","text":""},{"location":"reference/common/utilities/function_helper/","title":"Function helper","text":""},{"location":"reference/common/utilities/function_helper/#common.utilities.function_helper.calculate_distance_m","title":"<code>calculate_distance_m(lat1, lon1, lat2, lon2)</code>","text":"<p>Returns distance, in kilometers, between one set of longitude/latitude coordinates and another</p> Source code in <code>src/common/utilities/function_helper.py</code> <pre><code>def calculate_distance_m(lat1, lon1, lat2, lon2):\n    \"\"\"Returns distance, in kilometers, between one set of longitude/latitude\n    coordinates and another\"\"\"\n    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])\n\n    newlon = lon2 - lon1\n    newlat = lat2 - lat1\n\n    haver_formula = (\n        np.sin(newlat / 2.0) ** 2\n        + np.cos(lat1) * np.cos(lat2) * np.sin(newlon / 2.0) ** 2\n    )\n\n    dist = 2 * np.arcsin(np.sqrt(haver_formula))\n    m = (6367 * dist) * 1000  # 6367 for distance in m for miles use 3958\n    return m\n</code></pre>"},{"location":"reference/nrg_parser/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/constants/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/constants/iea_mapping_config/","title":"Iea mapping config","text":""},{"location":"reference/nrg_parser/mast/logger_model/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/logger_model/nrg/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/","title":"Symphoniepro txt reader","text":""},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProSiteInfo","title":"<code>SymphonieProSiteInfo</code>","text":"<p>Symphonie Text File format header object. This class contains site basic information on the data log file.</p> Source code in <code>src/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader.py</code> <pre><code>class SymphonieProSiteInfo:\n    \"\"\"\n    Symphonie Text File format header object.\n    This class contains site basic information on the data log file.\n    \"\"\"\n\n    site_number = None\n    site_description = None\n    project = None\n    tower = None\n    location = None\n    coordinate_system = None\n    latitude = None\n    longitude = None\n    elevation = None\n    timezone = None\n    site_units = None\n    logger_date = None\n    logger_model = None\n    logger_sn = None\n    logger_firmware = None\n    ipack_model = None\n    ipack_sn = None\n    ipack_firmware = None\n</code></pre>"},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProTxtReader","title":"<code>SymphonieProTxtReader</code>","text":"<p>Symphonie Text File Reader This class takes Symphonie Desktop Pro rld -&gt; txt converted file.</p> Source code in <code>src/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader.py</code> <pre><code>class SymphonieProTxtReader:\n    \"\"\"\n    Symphonie Text File Reader\n    This class takes Symphonie Desktop Pro rld -&gt; txt converted file.\n    \"\"\"\n\n    def __init__(self, txt_filepath: str):\n        \"\"\"\n        Initializes SymphonieProTxt by reading/parsing its file content,\n        both headers and timeseries data.\n\n        Parameters:\n        -----------\n            txt_filepath: symphonie pro txt data file path\n\n        Attributes:\n        -----------\n        first_timestamp: datetime\n        last_timestamp: datetime\n        header_sections_dict: dict\n        sensor_history_list: list\n        header_line_ctr: int \n        \"\"\"\n        # initialize\n        self.header_sections_dict = {}\n        self.sensor_history_list = []\n        self.header_line_ctr = 0\n        self.timeseries_data = pd.DataFrame()\n        self.first_timestamp = None\n        self.last_timestamp = None\n\n        # do parameter check here, if file exist, file not empty\n\n        try:\n            # read headers start\n            line_ctr = 0\n\n            logger.debug(f\"opening file: {txt_filepath}\")\n            with open(txt_filepath, \"rt\") as file_data:\n                for line in file_data:\n                    line_ctr += 1\n                    line = line.strip()\n\n                    if line == \"Data\":\n                        break\n                    if line == \"Sensor History\":\n                        continue\n\n                    # initialize section settings:\n                    section_name = line\n                    section = {}\n\n                    # sensor history -- channel definition\n                    if line.startswith(\"Channel:\"):\n                        split_arr = line.split(\":\", 1)\n                        section[split_arr[0].strip()] = split_arr[1].strip()\n                        section_name = \"Ch_\" + split_arr[1].strip()\n\n                    # header section loop\n                    for line in file_data:\n                        line_ctr += 1\n                        str_line = line.strip()\n                        if (\n                            str_line == \"Data\"\n                        ):  # means timeseries section, break from section loop\n                            break\n                        elif (\n                            str_line == \"\"\n                        ):  # if empty, it means new section break from section loop\n                            break\n                        elif str_line.find(\":\") != -1:  # normal header data\n                            split_arr = str_line.split(\":\", 1)\n                            section[split_arr[0].strip()] = util_func.try_string(\n                                split_arr[1].strip()\n                            )\n\n                    if section_name.startswith(\"Ch_\"):\n                        self.sensor_history_list.append(section)\n                    else:\n                        self.header_sections_dict[section_name] = section\n\n            self.header_line_ctr = line_ctr\n\n            # read headers end\n\n            # read timeseries data\n            try:\n                self.timeseries_data = pd.read_csv(\n                    txt_filepath,\n                    skiprows=self.header_line_ctr,\n                    sep=\"\\t\",\n                    encoding=\"utf-8\",\n                )\n            except Exception:\n                logger.debug(traceback.format_exc())\n                pass  # file has no data\n\n            # get first and last timestamp if timeseries data is available\n            if len(self.timeseries_data) &gt; 0:\n                self.timeseries_data[\"Timestamp\"] = pd.to_datetime(\n                    self.timeseries_data[\"Timestamp\"], errors=\"coerce\"\n                )\n                self.first_timestamp = self.timeseries_data[\"Timestamp\"].min()\n                self.last_timestamp = self.timeseries_data[\"Timestamp\"].max()\n\n        except Exception as e:\n            # handle any possible exception\n            logging.error(f\"Failed to load file {txt_filepath} error: str{e}\")\n\n    def get_all_metadata(self):\n        self.get_header()\n        self.get_site_info()\n        self.get_iea_logger_main_config()\n        self.get_iea_sensor_config()\n\n    def get_header(self, header_section_name=None, header=None):\n        \"\"\"\n        Helper method that returns symphonie pro txt file in dictionary format if\n        header is not given, else return header value.\n\n        Args:\n            header_section_name: section headers name in symphonie pro txt file\n            header: headers name in symphonie pro txt file\n        \"\"\"\n\n        if header_section_name is None:\n            return self.header_sections_dict  # return all headers in dict\n\n        if header_section_name in self.header_sections_dict:\n            section = self.header_sections_dict[header_section_name]\n            if header is not None:\n                if header in section:\n                    self.header = section[header]\n                    return section[header]\n                else:\n                    logging.debug(f\"{header} header does not exists.\")\n                    self.header = None\n                    return None\n            else:\n                self.header = section\n                return section\n\n        else:\n            logging.debug(f\"{header_section_name} section does not exists\")\n            self.header = None\n            return None\n\n    def get_site_info(self):\n        \"\"\"\n        Helper method that returns SymphonieProSiteInfo\n        SymphoniePRO basic site information from the headers\n\n        Returns:\n            site_info - Symphonie Pro site information\n        \"\"\"\n        site_info = SymphonieProSiteInfo()\n\n        # Export Parameters\n        exp_params = \"Export Parameters\"\n        site_info.site_number = self.get_header(\n            header_section_name=exp_params, header=\"Site Number\"\n        )\n\n        # site properties\n        site_properties = \"Site Properties\"\n        site_info.site_description = self.get_header(\n            header_section_name=site_properties, header=\"Site Description\"\n        )\n        site_info.project = self.get_header(\n            header_section_name=site_properties, header=\"Project\"\n        )\n        site_info.tower = self.get_header(\n            header_section_name=site_properties, header=\"Tower\"\n        )\n        site_info.location = self.get_header(\n            header_section_name=site_properties, header=\"Location\"\n        )\n        site_info.coordinate_system = self.get_header(\n            header_section_name=site_properties, header=\"Coordinate System\"\n        )\n        site_info.latitude = util_func.try_float(\n            self.get_header(header_section_name=site_properties, header=\"Latitude\")\n        )\n        site_info.longitude = util_func.try_float(\n            self.get_header(header_section_name=site_properties, header=\"Longitude\")\n        )\n        site_info.elevation = util_func.try_int(\n            self.get_header(header_section_name=site_properties, header=\"Elevation\")\n        )\n        site_info.timezone = self.get_header(\n            header_section_name=site_properties, header=\"Time Zone\"\n        )\n        site_info.site_units = self.get_header(\n            header_section_name=site_properties, header=\"Site Units\"\n        )\n\n        # logger history\n        logger_history = \"Logger History\"\n        site_info.logger_date = self.get_header(\n            header_section_name=logger_history, header=\"Date\"\n        )\n        site_info.logger_model = self.get_header(\n            header_section_name=logger_history, header=\"Model\"\n        )\n        site_info.logger_sn = self.get_header(\n            header_section_name=logger_history, header=\"Serial Number\"\n        )\n        site_info.logger_firmware = self.get_header(\n            header_section_name=logger_history, header=\"Firmware\"\n        )\n\n        # iPack History\n        ipack_history = \"iPack History\"\n        site_info.ipack_model = self.get_header(\n            header_section_name=ipack_history, header=\"Model\"\n        )\n        site_info.ipack_sn = self.get_header(\n            header_section_name=ipack_history, header=\"Serial Number\"\n        )\n        site_info.ipack_firmware = self.get_header(\n            header_section_name=ipack_history, header=\"Firmware\"\n        )\n\n        self.site_info = site_info\n\n    def get_iea_logger_main_config(self):\n        \"\"\"\n        Helper method that returns the logger main configuration in IEATask43 format\n        Returns:\n            logger_main_config_dict: logger main configuration in dictionary format\n        \"\"\"\n\n        logger_main_config_dict = {}\n\n        # header sections\n        logger_history = \"Logger History\"\n        exp_params = \"Export Parameters\"\n        site_properties = \"Site Properties\"\n\n        logger_main_config_dict[\"logger_serial_number\"] = self.get_header(\n            header_section_name=logger_history, header=\"Serial Number\"\n        )\n        logger_main_config_dict[\"logger_model_name\"] = self.get_header(\n            header_section_name=logger_history, header=\"Model\"\n        )\n        logger_main_config_dict[\"logger_id\"] = self.get_header(\n            header_section_name=exp_params, header=\"Site Number\"\n        )\n        logger_main_config_dict[\"logger_name\"] = self.get_header(\n            header_section_name=site_properties, header=\"Project\"\n        )\n\n        logger_main_config_dict[\"date_from\"] = self.first_timestamp\n        logger_main_config_dict[\"date_to\"] = self.last_timestamp\n\n        logger_main_config_dict[\"latitude_ddeg\"] = util_func.try_float(\n            self.get_header(header_section_name=site_properties, header=\"Latitude\")\n        )\n        logger_main_config_dict[\"longitude_ddeg\"] = util_func.try_float(\n            self.get_header(header_section_name=site_properties, header=\"Longitude\")\n        )\n        logger_main_config_dict[\"measurement_station_type_id\"] = \"mast\"\n        logger_main_config_dict[\"offset_from_utc_hrs\"] = util_func.try_float(\n            self.get_header(header_section_name=site_properties, header=\"Time Zone\")\n            .replace(\"UTC\", \"\")\n            .replace(\":\", \".\")\n        )\n        logger_main_config_dict[\"firmware_version\"] = self.get_header(\n            header_section_name=logger_history, header=\"Firmware\"\n        )\n        self.logger_main_config_dict = logger_main_config_dict\n\n    def get_iea_sensor_config(self):\n        \"\"\"\n        Helper method that returns the measurement point and sensor configuration in IEATask43 format\n        Returns:\n            sensor_config_dict_list: list of measurement points and sensor configurations (dict)\n        \"\"\"\n        sensor_config_dict_list = []\n        column_headers = list(self.timeseries_data.columns.values)\n\n        # mast sensor configuration\n        for ch_info in self.sensor_history_list:\n            sensor_config_dict = {}\n            match ch_info[\"Type\"]:\n                case \"Calculated\":\n                    pass\n                    # sensor_config_dict[\"sensor_serial_number\"] = None\n                    # sensor_config_dict[\"logger_height\"] = None\n                    # sensor_config_dict[\"logger_slope\"] = None\n                    # sensor_config_dict[\"boom_orientation_deg\"] = None\n                case _:\n                    sensor_config_dict[\"connection_channel\"] = util_func.try_int(ch_info[\"Channel\"])\n                    sensor_config_dict[\"sensor_serial_number\"] = ch_info[\"Serial Number\"]\n                    sensor_config_dict[\"logger_height\"] = util_func.try_float(ch_info[\"Height\"])\n                    sensor_config_dict[\"logger_slope\"] = util_func.try_float(\n                        ch_info[\"Scale Factor\"]\n                    )\n                    sensor_config_dict[\"logger_offset\"] = util_func.try_float(ch_info[\"Offset\"])\n                    sensor_config_dict[\"boom_orientation_deg\"] = util_func.try_float(\n                        ch_info[\"Bearing\"]\n                    )\n                    sensor_config_dict[\"boom_orientation_deg\"] = util_func.try_float(\n                        ch_info[\"Bearing\"]\n                    )\n            if ch_info[\"Units\"] is not None:\n                if ch_info[\"Units\"].lower() in iea_mapping_config.IEA_UNIT_DICT:\n                    # map unit to iea task43\n                    sensor_config_dict[\n                        \"measurement_unit_id\"\n                    ] = iea_mapping_config.IEA_UNIT_DICT[ch_info[\"Units\"].lower()]\n                else:\n                    sensor_config_dict[\"measurement_unit_id\"] = \"-\"\n            else:\n                sensor_config_dict[\"measurement_unit_id\"] = None\n\n            if ch_info[\"Type\"] == \"Vane\":\n                sensor_config_dict[\n                    \"vane_dead_band_orientation_deg\"\n                ] = util_func.try_float(ch_info[\"Vane Mounting Angle\"])\n\n            match sensor_config_dict[\"measurement_unit_id\"]:\n                case \"m/s\":\n                    sensor_config_dict[\"measurement_type\"] = \"wind_speed\"\n                    sensor_config_dict[\"sensor_type\"] = \"anemometer\"\n                case \"deg\":\n                    sensor_config_dict[\"measurement_type\"] = \"wind_direction\"\n                    sensor_config_dict[\"sensor_type\"] = \"wind_vane\"\n                case \"deg_C\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_temperature\"\n                    sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n                case \"deg_F\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_temperature\"\n                    sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n                case \"K\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_temperature\"\n                    sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n                case \"%\":\n                    sensor_config_dict[\"measurement_type\"] = \"relative_humidity\"\n                    sensor_config_dict[\"sensor_type\"] = \"hygrometer\"\n                case \"mbar\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                    sensor_config_dict[\"sensor_type\"] = \"barometer\"\n                case \"hPa\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                    sensor_config_dict[\"sensor_type\"] = \"barometer\"\n                case \"atm\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                    sensor_config_dict[\"sensor_type\"] = \"barometer\"\n                case \"mmHg\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                    sensor_config_dict[\"sensor_type\"] = \"barometer\"\n                case \"inHg\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                    sensor_config_dict[\"sensor_type\"] = \"barometer\"\n                case \"kg/m^2\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                    sensor_config_dict[\"sensor_type\"] = \"barometer\"\n                case \"kg/m^3\":\n                    sensor_config_dict[\"measurement_type\"] = \"air_density\"\n                    sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n                case \"V\":\n                    sensor_config_dict[\"measurement_type\"] = \"voltage\"\n                    sensor_config_dict[\"sensor_type\"] = \"voltmeter\"\n                case \"mA\":\n                    sensor_config_dict[\"measurement_type\"] = \"current\"\n                    sensor_config_dict[\"sensor_type\"] = \"ammeter\"\n                case \"A\":\n                    sensor_config_dict[\"measurement_type\"] = \"current\"\n                    sensor_config_dict[\"sensor_type\"] = \"ammeter\"\n                case \"ohm\":\n                    sensor_config_dict[\"measurement_type\"] = \"resistance\"\n                    sensor_config_dict[\"sensor_type\"] = \"ice_detection_sensor\"\n                case \"mm\":\n                    sensor_config_dict[\"measurement_type\"] = \"precipitation\"\n                    sensor_config_dict[\"sensor_type\"] = \"rain_gauge\"\n                case \"W/m^2\":\n                    sensor_config_dict[\n                        \"measurement_type\"\n                    ] = \"global_horizontal_irradiance\"\n                    sensor_config_dict[\"sensor_type\"] = \"pyranometer\"\n                case _:\n                    sensor_config_dict[\"sensor_type\"] = \"other\"\n                    sensor_config_dict[\"measurement_type\"] = \"other\"\n\n            sensor_config_dict[\"date_from\"] = self.first_timestamp\n            sensor_config_dict[\"date_to\"] = self.last_timestamp\n\n            column_name_list = []\n            ch_header = [\n                columns\n                for columns in column_headers\n                if columns.startswith(\"Ch\" + ch_info[\"Channel\"] + \"_\")\n            ]\n\n            for column in ch_header:\n                # parse statistic type\n                chunks = column.split(\"_\")\n                statistic_type = chunks[len(chunks) - 2].lower()\n\n                if statistic_type == \"gustdir\":\n                    statistic_type = \"gust\"\n\n                if statistic_type in iea_mapping_config.IEA_STATISTIC_TYPE:\n                    statistic_type = statistic_type\n                else:\n                    statistic_type = \"avg\"\n\n                column_name = column + \"#\" + statistic_type\n                column_name_list.append(column_name)\n\n            sensor_config_dict[\"column_name_list\"] = \";\".join(column_name_list)\n            sensor_config_dict_list.append(sensor_config_dict)\n\n        self.sensor_config_dict_list = sensor_config_dict_list\n</code></pre>"},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProTxtReader.__init__","title":"<code>__init__(txt_filepath)</code>","text":"<p>Initializes SymphonieProTxt by reading/parsing its file content, both headers and timeseries data.</p> <pre><code>txt_filepath: symphonie pro txt data file path\n</code></pre>"},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProTxtReader.__init__--attributes","title":"Attributes:","text":"<p>first_timestamp: datetime last_timestamp: datetime header_sections_dict: dict sensor_history_list: list header_line_ctr: int</p> Source code in <code>src/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader.py</code> <pre><code>def __init__(self, txt_filepath: str):\n    \"\"\"\n    Initializes SymphonieProTxt by reading/parsing its file content,\n    both headers and timeseries data.\n\n    Parameters:\n    -----------\n        txt_filepath: symphonie pro txt data file path\n\n    Attributes:\n    -----------\n    first_timestamp: datetime\n    last_timestamp: datetime\n    header_sections_dict: dict\n    sensor_history_list: list\n    header_line_ctr: int \n    \"\"\"\n    # initialize\n    self.header_sections_dict = {}\n    self.sensor_history_list = []\n    self.header_line_ctr = 0\n    self.timeseries_data = pd.DataFrame()\n    self.first_timestamp = None\n    self.last_timestamp = None\n\n    # do parameter check here, if file exist, file not empty\n\n    try:\n        # read headers start\n        line_ctr = 0\n\n        logger.debug(f\"opening file: {txt_filepath}\")\n        with open(txt_filepath, \"rt\") as file_data:\n            for line in file_data:\n                line_ctr += 1\n                line = line.strip()\n\n                if line == \"Data\":\n                    break\n                if line == \"Sensor History\":\n                    continue\n\n                # initialize section settings:\n                section_name = line\n                section = {}\n\n                # sensor history -- channel definition\n                if line.startswith(\"Channel:\"):\n                    split_arr = line.split(\":\", 1)\n                    section[split_arr[0].strip()] = split_arr[1].strip()\n                    section_name = \"Ch_\" + split_arr[1].strip()\n\n                # header section loop\n                for line in file_data:\n                    line_ctr += 1\n                    str_line = line.strip()\n                    if (\n                        str_line == \"Data\"\n                    ):  # means timeseries section, break from section loop\n                        break\n                    elif (\n                        str_line == \"\"\n                    ):  # if empty, it means new section break from section loop\n                        break\n                    elif str_line.find(\":\") != -1:  # normal header data\n                        split_arr = str_line.split(\":\", 1)\n                        section[split_arr[0].strip()] = util_func.try_string(\n                            split_arr[1].strip()\n                        )\n\n                if section_name.startswith(\"Ch_\"):\n                    self.sensor_history_list.append(section)\n                else:\n                    self.header_sections_dict[section_name] = section\n\n        self.header_line_ctr = line_ctr\n\n        # read headers end\n\n        # read timeseries data\n        try:\n            self.timeseries_data = pd.read_csv(\n                txt_filepath,\n                skiprows=self.header_line_ctr,\n                sep=\"\\t\",\n                encoding=\"utf-8\",\n            )\n        except Exception:\n            logger.debug(traceback.format_exc())\n            pass  # file has no data\n\n        # get first and last timestamp if timeseries data is available\n        if len(self.timeseries_data) &gt; 0:\n            self.timeseries_data[\"Timestamp\"] = pd.to_datetime(\n                self.timeseries_data[\"Timestamp\"], errors=\"coerce\"\n            )\n            self.first_timestamp = self.timeseries_data[\"Timestamp\"].min()\n            self.last_timestamp = self.timeseries_data[\"Timestamp\"].max()\n\n    except Exception as e:\n        # handle any possible exception\n        logging.error(f\"Failed to load file {txt_filepath} error: str{e}\")\n</code></pre>"},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProTxtReader.get_header","title":"<code>get_header(header_section_name=None, header=None)</code>","text":"<p>Helper method that returns symphonie pro txt file in dictionary format if header is not given, else return header value.</p> <p>Parameters:</p> Name Type Description Default <code>header_section_name</code> <p>section headers name in symphonie pro txt file</p> <code>None</code> <code>header</code> <p>headers name in symphonie pro txt file</p> <code>None</code> Source code in <code>src/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader.py</code> <pre><code>def get_header(self, header_section_name=None, header=None):\n    \"\"\"\n    Helper method that returns symphonie pro txt file in dictionary format if\n    header is not given, else return header value.\n\n    Args:\n        header_section_name: section headers name in symphonie pro txt file\n        header: headers name in symphonie pro txt file\n    \"\"\"\n\n    if header_section_name is None:\n        return self.header_sections_dict  # return all headers in dict\n\n    if header_section_name in self.header_sections_dict:\n        section = self.header_sections_dict[header_section_name]\n        if header is not None:\n            if header in section:\n                self.header = section[header]\n                return section[header]\n            else:\n                logging.debug(f\"{header} header does not exists.\")\n                self.header = None\n                return None\n        else:\n            self.header = section\n            return section\n\n    else:\n        logging.debug(f\"{header_section_name} section does not exists\")\n        self.header = None\n        return None\n</code></pre>"},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProTxtReader.get_iea_logger_main_config","title":"<code>get_iea_logger_main_config()</code>","text":"<p>Helper method that returns the logger main configuration in IEATask43 format Returns:     logger_main_config_dict: logger main configuration in dictionary format</p> Source code in <code>src/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader.py</code> <pre><code>def get_iea_logger_main_config(self):\n    \"\"\"\n    Helper method that returns the logger main configuration in IEATask43 format\n    Returns:\n        logger_main_config_dict: logger main configuration in dictionary format\n    \"\"\"\n\n    logger_main_config_dict = {}\n\n    # header sections\n    logger_history = \"Logger History\"\n    exp_params = \"Export Parameters\"\n    site_properties = \"Site Properties\"\n\n    logger_main_config_dict[\"logger_serial_number\"] = self.get_header(\n        header_section_name=logger_history, header=\"Serial Number\"\n    )\n    logger_main_config_dict[\"logger_model_name\"] = self.get_header(\n        header_section_name=logger_history, header=\"Model\"\n    )\n    logger_main_config_dict[\"logger_id\"] = self.get_header(\n        header_section_name=exp_params, header=\"Site Number\"\n    )\n    logger_main_config_dict[\"logger_name\"] = self.get_header(\n        header_section_name=site_properties, header=\"Project\"\n    )\n\n    logger_main_config_dict[\"date_from\"] = self.first_timestamp\n    logger_main_config_dict[\"date_to\"] = self.last_timestamp\n\n    logger_main_config_dict[\"latitude_ddeg\"] = util_func.try_float(\n        self.get_header(header_section_name=site_properties, header=\"Latitude\")\n    )\n    logger_main_config_dict[\"longitude_ddeg\"] = util_func.try_float(\n        self.get_header(header_section_name=site_properties, header=\"Longitude\")\n    )\n    logger_main_config_dict[\"measurement_station_type_id\"] = \"mast\"\n    logger_main_config_dict[\"offset_from_utc_hrs\"] = util_func.try_float(\n        self.get_header(header_section_name=site_properties, header=\"Time Zone\")\n        .replace(\"UTC\", \"\")\n        .replace(\":\", \".\")\n    )\n    logger_main_config_dict[\"firmware_version\"] = self.get_header(\n        header_section_name=logger_history, header=\"Firmware\"\n    )\n    self.logger_main_config_dict = logger_main_config_dict\n</code></pre>"},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProTxtReader.get_iea_sensor_config","title":"<code>get_iea_sensor_config()</code>","text":"<p>Helper method that returns the measurement point and sensor configuration in IEATask43 format Returns:     sensor_config_dict_list: list of measurement points and sensor configurations (dict)</p> Source code in <code>src/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader.py</code> <pre><code>def get_iea_sensor_config(self):\n    \"\"\"\n    Helper method that returns the measurement point and sensor configuration in IEATask43 format\n    Returns:\n        sensor_config_dict_list: list of measurement points and sensor configurations (dict)\n    \"\"\"\n    sensor_config_dict_list = []\n    column_headers = list(self.timeseries_data.columns.values)\n\n    # mast sensor configuration\n    for ch_info in self.sensor_history_list:\n        sensor_config_dict = {}\n        match ch_info[\"Type\"]:\n            case \"Calculated\":\n                pass\n                # sensor_config_dict[\"sensor_serial_number\"] = None\n                # sensor_config_dict[\"logger_height\"] = None\n                # sensor_config_dict[\"logger_slope\"] = None\n                # sensor_config_dict[\"boom_orientation_deg\"] = None\n            case _:\n                sensor_config_dict[\"connection_channel\"] = util_func.try_int(ch_info[\"Channel\"])\n                sensor_config_dict[\"sensor_serial_number\"] = ch_info[\"Serial Number\"]\n                sensor_config_dict[\"logger_height\"] = util_func.try_float(ch_info[\"Height\"])\n                sensor_config_dict[\"logger_slope\"] = util_func.try_float(\n                    ch_info[\"Scale Factor\"]\n                )\n                sensor_config_dict[\"logger_offset\"] = util_func.try_float(ch_info[\"Offset\"])\n                sensor_config_dict[\"boom_orientation_deg\"] = util_func.try_float(\n                    ch_info[\"Bearing\"]\n                )\n                sensor_config_dict[\"boom_orientation_deg\"] = util_func.try_float(\n                    ch_info[\"Bearing\"]\n                )\n        if ch_info[\"Units\"] is not None:\n            if ch_info[\"Units\"].lower() in iea_mapping_config.IEA_UNIT_DICT:\n                # map unit to iea task43\n                sensor_config_dict[\n                    \"measurement_unit_id\"\n                ] = iea_mapping_config.IEA_UNIT_DICT[ch_info[\"Units\"].lower()]\n            else:\n                sensor_config_dict[\"measurement_unit_id\"] = \"-\"\n        else:\n            sensor_config_dict[\"measurement_unit_id\"] = None\n\n        if ch_info[\"Type\"] == \"Vane\":\n            sensor_config_dict[\n                \"vane_dead_band_orientation_deg\"\n            ] = util_func.try_float(ch_info[\"Vane Mounting Angle\"])\n\n        match sensor_config_dict[\"measurement_unit_id\"]:\n            case \"m/s\":\n                sensor_config_dict[\"measurement_type\"] = \"wind_speed\"\n                sensor_config_dict[\"sensor_type\"] = \"anemometer\"\n            case \"deg\":\n                sensor_config_dict[\"measurement_type\"] = \"wind_direction\"\n                sensor_config_dict[\"sensor_type\"] = \"wind_vane\"\n            case \"deg_C\":\n                sensor_config_dict[\"measurement_type\"] = \"air_temperature\"\n                sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n            case \"deg_F\":\n                sensor_config_dict[\"measurement_type\"] = \"air_temperature\"\n                sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n            case \"K\":\n                sensor_config_dict[\"measurement_type\"] = \"air_temperature\"\n                sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n            case \"%\":\n                sensor_config_dict[\"measurement_type\"] = \"relative_humidity\"\n                sensor_config_dict[\"sensor_type\"] = \"hygrometer\"\n            case \"mbar\":\n                sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                sensor_config_dict[\"sensor_type\"] = \"barometer\"\n            case \"hPa\":\n                sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                sensor_config_dict[\"sensor_type\"] = \"barometer\"\n            case \"atm\":\n                sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                sensor_config_dict[\"sensor_type\"] = \"barometer\"\n            case \"mmHg\":\n                sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                sensor_config_dict[\"sensor_type\"] = \"barometer\"\n            case \"inHg\":\n                sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                sensor_config_dict[\"sensor_type\"] = \"barometer\"\n            case \"kg/m^2\":\n                sensor_config_dict[\"measurement_type\"] = \"air_pressure\"\n                sensor_config_dict[\"sensor_type\"] = \"barometer\"\n            case \"kg/m^3\":\n                sensor_config_dict[\"measurement_type\"] = \"air_density\"\n                sensor_config_dict[\"sensor_type\"] = \"thermometer\"\n            case \"V\":\n                sensor_config_dict[\"measurement_type\"] = \"voltage\"\n                sensor_config_dict[\"sensor_type\"] = \"voltmeter\"\n            case \"mA\":\n                sensor_config_dict[\"measurement_type\"] = \"current\"\n                sensor_config_dict[\"sensor_type\"] = \"ammeter\"\n            case \"A\":\n                sensor_config_dict[\"measurement_type\"] = \"current\"\n                sensor_config_dict[\"sensor_type\"] = \"ammeter\"\n            case \"ohm\":\n                sensor_config_dict[\"measurement_type\"] = \"resistance\"\n                sensor_config_dict[\"sensor_type\"] = \"ice_detection_sensor\"\n            case \"mm\":\n                sensor_config_dict[\"measurement_type\"] = \"precipitation\"\n                sensor_config_dict[\"sensor_type\"] = \"rain_gauge\"\n            case \"W/m^2\":\n                sensor_config_dict[\n                    \"measurement_type\"\n                ] = \"global_horizontal_irradiance\"\n                sensor_config_dict[\"sensor_type\"] = \"pyranometer\"\n            case _:\n                sensor_config_dict[\"sensor_type\"] = \"other\"\n                sensor_config_dict[\"measurement_type\"] = \"other\"\n\n        sensor_config_dict[\"date_from\"] = self.first_timestamp\n        sensor_config_dict[\"date_to\"] = self.last_timestamp\n\n        column_name_list = []\n        ch_header = [\n            columns\n            for columns in column_headers\n            if columns.startswith(\"Ch\" + ch_info[\"Channel\"] + \"_\")\n        ]\n\n        for column in ch_header:\n            # parse statistic type\n            chunks = column.split(\"_\")\n            statistic_type = chunks[len(chunks) - 2].lower()\n\n            if statistic_type == \"gustdir\":\n                statistic_type = \"gust\"\n\n            if statistic_type in iea_mapping_config.IEA_STATISTIC_TYPE:\n                statistic_type = statistic_type\n            else:\n                statistic_type = \"avg\"\n\n            column_name = column + \"#\" + statistic_type\n            column_name_list.append(column_name)\n\n        sensor_config_dict[\"column_name_list\"] = \";\".join(column_name_list)\n        sensor_config_dict_list.append(sensor_config_dict)\n\n    self.sensor_config_dict_list = sensor_config_dict_list\n</code></pre>"},{"location":"reference/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader/#nrg_parser.mast.logger_model.nrg.reader.symphoniepro_txt_reader.SymphonieProTxtReader.get_site_info","title":"<code>get_site_info()</code>","text":"<p>Helper method that returns SymphonieProSiteInfo SymphoniePRO basic site information from the headers</p> <p>Returns:</p> Type Description <p>site_info - Symphonie Pro site information</p> Source code in <code>src/nrg_parser/mast/logger_model/nrg/reader/symphoniepro_txt_reader.py</code> <pre><code>def get_site_info(self):\n    \"\"\"\n    Helper method that returns SymphonieProSiteInfo\n    SymphoniePRO basic site information from the headers\n\n    Returns:\n        site_info - Symphonie Pro site information\n    \"\"\"\n    site_info = SymphonieProSiteInfo()\n\n    # Export Parameters\n    exp_params = \"Export Parameters\"\n    site_info.site_number = self.get_header(\n        header_section_name=exp_params, header=\"Site Number\"\n    )\n\n    # site properties\n    site_properties = \"Site Properties\"\n    site_info.site_description = self.get_header(\n        header_section_name=site_properties, header=\"Site Description\"\n    )\n    site_info.project = self.get_header(\n        header_section_name=site_properties, header=\"Project\"\n    )\n    site_info.tower = self.get_header(\n        header_section_name=site_properties, header=\"Tower\"\n    )\n    site_info.location = self.get_header(\n        header_section_name=site_properties, header=\"Location\"\n    )\n    site_info.coordinate_system = self.get_header(\n        header_section_name=site_properties, header=\"Coordinate System\"\n    )\n    site_info.latitude = util_func.try_float(\n        self.get_header(header_section_name=site_properties, header=\"Latitude\")\n    )\n    site_info.longitude = util_func.try_float(\n        self.get_header(header_section_name=site_properties, header=\"Longitude\")\n    )\n    site_info.elevation = util_func.try_int(\n        self.get_header(header_section_name=site_properties, header=\"Elevation\")\n    )\n    site_info.timezone = self.get_header(\n        header_section_name=site_properties, header=\"Time Zone\"\n    )\n    site_info.site_units = self.get_header(\n        header_section_name=site_properties, header=\"Site Units\"\n    )\n\n    # logger history\n    logger_history = \"Logger History\"\n    site_info.logger_date = self.get_header(\n        header_section_name=logger_history, header=\"Date\"\n    )\n    site_info.logger_model = self.get_header(\n        header_section_name=logger_history, header=\"Model\"\n    )\n    site_info.logger_sn = self.get_header(\n        header_section_name=logger_history, header=\"Serial Number\"\n    )\n    site_info.logger_firmware = self.get_header(\n        header_section_name=logger_history, header=\"Firmware\"\n    )\n\n    # iPack History\n    ipack_history = \"iPack History\"\n    site_info.ipack_model = self.get_header(\n        header_section_name=ipack_history, header=\"Model\"\n    )\n    site_info.ipack_sn = self.get_header(\n        header_section_name=ipack_history, header=\"Serial Number\"\n    )\n    site_info.ipack_firmware = self.get_header(\n        header_section_name=ipack_history, header=\"Firmware\"\n    )\n\n    self.site_info = site_info\n</code></pre>"},{"location":"reference/nrg_parser/mast/utilities/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/utilities/iea_json/","title":"Index","text":""},{"location":"reference/nrg_parser/mast/utilities/iea_json/convert_to_iea_json/","title":"Convert to iea json","text":""},{"location":"reference/nrg_parser/mast/utilities/iea_json/convert_to_iea_json/#nrg_parser.mast.utilities.iea_json.convert_to_iea_json.calculate_distance_m","title":"<code>calculate_distance_m(lat1, lon1, lat2, lon2)</code>","text":"<p>Returns distance, in metere, between one set of longitude/latitude coordinates and another</p> Source code in <code>src/nrg_parser/mast/utilities/iea_json/convert_to_iea_json.py</code> <pre><code>def calculate_distance_m(lat1, lon1, lat2, lon2):\n    \"\"\"Returns distance, in metere, between one set of longitude/latitude coordinates and another\"\"\"\n    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])\n\n    newlon = lon2 - lon1\n    newlat = lat2 - lat1\n\n    haver_formula = (\n        np.sin(newlat / 2.0) ** 2\n        + np.cos(lat1) * np.cos(lat2) * np.sin(newlon / 2.0) ** 2\n    )\n\n    dist = 2 * np.arcsin(np.sqrt(haver_formula))\n    m = (6367 * dist) * 1000  # 6367 for distance in m for miles use 3958\n\n    return m\n</code></pre>"},{"location":"reference/nrg_parser/mast/utilities/iea_json/create_iea_json_nrg/","title":"Create iea json nrg","text":""},{"location":"reference/nrg_parser/mast/utilities/iea_json/create_iea_json_nrg/#nrg_parser.mast.utilities.iea_json.create_iea_json_nrg.main","title":"<code>main()</code>","text":"<p>Creates IEA-task43 json from NRG Symphonie Pro logger data files SymPRO Desktop PRO must be installed. Please specify installation location in nrg_config.py Args:     project_name(str): ex: Morgan-County     local_path(str): local path directory where logger data files(.rld) are located</p> <p>Output: iea_task43.json file under local path</p> Source code in <code>src/nrg_parser/mast/utilities/iea_json/create_iea_json_nrg.py</code> <pre><code>def main():\n    \"\"\"Creates IEA-task43 json from NRG Symphonie Pro logger data files\n    SymPRO Desktop PRO must be installed. Please specify installation location in nrg_config.py\n    Args:\n        project_name(str): ex: Morgan-County\n        local_path(str): local path directory where logger data files(.rld) are located\n\n    Output: iea_task43.json file under local path\n    \"\"\"\n\n    logging.info(\"IN execute - NRG Systems\")\n    project_name = sys.argv[1]\n    local_path = sys.argv[2]\n\n    # check if path exists\n\n    if not os.path.isdir(local_path):\n        logging.error(\n            f\"Local path {local_path} does not exists. Please confirm rld path directory.\"\n        )\n        return\n\n    local_path_dir_converted = os.path.join(local_path, \"converted\")\n\n    # converted folder doesn't exist, create\n    if not os.path.isdir(local_path_dir_converted):\n        os.mkdir(local_path_dir_converted)\n    else:\n        util_func.remove_files_in_dir(local_path_dir_converted)\n\n    process_start = time.perf_counter()\n\n    # convert rld binary - txt conversion\n    convert_start = time.perf_counter()\n\n    # get symphonie pro desktop app locations\n    if nrg_config.SYMPHONIE_APP is not None:\n        symphro_path = nrg_config.SYMPHONIE_APP\n    else:\n        symphro_path = \"C:/Program Files (x86)/Renewable NRG Systems/SymPRO Desktop/SymPRODesktop.exe\"\n\n    # # convert .rld file to txt\n    converter = nrgpy.local_rld(\n        rld_dir=local_path, out_dir=local_path_dir_converted, sympro_path=symphro_path\n    )\n    converter.convert()\n\n    convert_end = time.perf_counter()\n    logging.warning(\n        f\"PERF: Conversion {round(convert_end - convert_start, 2)} second(s)\"\n    )\n\n    # read and parse\n    logger_config_dict_list, sensor_config_dict_list = read_and_parse(\n        local_path_dir_converted\n    )\n    if len(logger_config_dict_list) &gt; 0 and len(sensor_config_dict_list) &gt; 0:\n        create_iea_json(\n            logger_config_dict_list,\n            sensor_config_dict_list,\n            local_path,\n            \"NRG SymphoniePro\",\n            project_name,\n        )\n\n    # remove all converted files after the run\n    util_func.remove_files_in_dir(local_path_dir_converted)\n\n    process_end = time.perf_counter()\n    logging.warning(\n        f\"PERF: PROCESS EXEC OVERALL: {round(process_end - process_start, 2)} second(s)\"\n    )\n    logging.info(f\"Please find the output file in {local_path}/iea_task43.json\")\n    logging.info(\"OUT execute - NRG Systems\")\n</code></pre>"},{"location":"reference/nrg_parser/mast/utilities/iea_json/iea_models/","title":"Iea models","text":""},{"location":"reference/nrg_parser/mast/utilities/iea_json/nrg_config/","title":"Nrg config","text":""}]}